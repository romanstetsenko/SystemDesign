
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Rate Limiter Documentation</title>
        <style>
            @media print {
                body {
                    font-family: Arial, sans-serif;
                    line-height: 1.5;
                    color: #000;
                    margin: 0.5in;
                    font-size: 11pt;
                }
                h1 {
                    font-size: 20pt;
                    color: #0066cc;
                    border-bottom: 2px solid #0066cc;
                    padding-bottom: 5px;
                    margin-bottom: 15px;
                }
                h2 {
                    font-size: 16pt;
                    color: #0066cc;
                    margin-top: 20px;
                    margin-bottom: 10px;
                    border-bottom: 1px solid #ccc;
                    padding-bottom: 3px;
                }
                h3 {
                    font-size: 14pt;
                    color: #333;
                    margin-top: 15px;
                    margin-bottom: 8px;
                }
                code {
                    background: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 3px;
                    font-family: 'Courier New', monospace;
                    font-size: 10pt;
                }
                pre {
                    background: #f5f5f5;
                    padding: 10px;
                    border-radius: 4px;
                    border-left: 3px solid #0066cc;
                    overflow-x: auto;
                    page-break-inside: avoid;
                }
                blockquote {
                    border-left: 4px solid #0066cc;
                    padding-left: 15px;
                    margin: 12px 0;
                    color: #555;
                    background: #f9f9f9;
                    font-style: italic;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin: 12px 0;
                    page-break-inside: avoid;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 6px;
                    text-align: left;
                    font-size: 10pt;
                }
                th {
                    background-color: #0066cc;
                    color: white;
                    font-weight: bold;
                }
                tr:nth-child(even) {
                    background-color: #f9f9f9;
                }
                ul, ol {
                    margin-left: 20px;
                    margin-top: 8px;
                    margin-bottom: 8px;
                }
                li {
                    margin-bottom: 4px;
                }
                a {
                    color: #0066cc;
                    text-decoration: none;
                }
                .mermaid-code {
                    background: #f0f8ff;
                    border: 1px dashed #0066cc;
                    padding: 12px;
                    margin: 12px 0;
                    border-radius: 4px;
                    page-break-inside: avoid;
                }
                .mermaid-code strong {
                    color: #0066cc;
                    display: block;
                    margin-bottom: 8px;
                }
                .mermaid-code pre {
                    background: white;
                    border: none;
                    margin: 0;
                    padding: 0;
                    font-size: 9pt;
                }
                .mermaid-code em {
                    color: #666;
                    font-size: 9pt;
                    display: block;
                    margin-top: 8px;
                }
                hr {
                    border: none;
                    border-top: 1px solid #ccc;
                    margin: 20px 0;
                }
                .header {
                    text-align: center;
                    margin-bottom: 30px;
                    padding-bottom: 15px;
                    border-bottom: 2px solid #0066cc;
                }
                .footer {
                    text-align: center;
                    font-size: 9pt;
                    color: #666;
                    margin-top: 30px;
                    padding-top: 10px;
                    border-top: 1px solid #ccc;
                }
            }
            
            /* Screen display styles */
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
            }
            h1, h2, h3, h4, h5, h6 {
                color: #2c3e50;
                margin-top: 1.5em;
                margin-bottom: 0.5em;
            }
            h1 { border-bottom: 2px solid #3498db; padding-bottom: 10px; }
            h2 { border-bottom: 1px solid #bdc3c7; padding-bottom: 5px; }
            code {
                background: #f8f9fa;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Courier New', monospace;
            }
            pre {
                background: #f8f9fa;
                padding: 15px;
                border-radius: 5px;
                border-left: 4px solid #3498db;
                overflow-x: auto;
            }
            blockquote {
                border-left: 4px solid #3498db;
                padding-left: 15px;
                margin: 15px 0;
                color: #555;
                background: #f8f9fa;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin: 15px 0;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #3498db;
                color: white;
            }
            tr:nth-child(even) {
                background-color: #f2f2f2;
            }
            .mermaid-code {
                background: #e8f4f8;
                border: 2px dashed #3498db;
                padding: 15px;
                margin: 15px 0;
                border-radius: 5px;
            }
            .mermaid-code strong {
                color: #3498db;
                display: block;
                margin-bottom: 8px;
            }
            .mermaid-code em {
                color: #666;
                font-size: 0.9em;
                display: block;
                margin-top: 8px;
            }
            hr {
                border: none;
                border-top: 1px solid #bdc3c7;
                margin: 20px 0;
            }
            ul, ol {
                margin-left: 20px;
            }
            a {
                color: #3498db;
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .header {
                text-align: center;
                margin-bottom: 30px;
                padding-bottom: 15px;
                border-bottom: 2px solid #3498db;
            }
            .footer {
                text-align: center;
                font-size: 0.9em;
                color: #666;
                margin-top: 30px;
                padding-top: 10px;
                border-top: 1px solid #bdc3c7;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>Rate Limiter Documentation</h1>
            <p style="color: #666; margin: 0;">Generated from Rate Limiter.md</p>
        </div>
        
        <h1><strong>RATE LIMITER SYSTEM DESIGN</strong></h1>
<h2><strong>1. Functional Requirements (What the rate limiter must do)</strong></h2>
<p>Enforce quotas (per IP, user, API key, service, tenant, endpoint).<br />
Support multiple policies (100/min, 10/sec, 1,000/hour, 5 login attempts/10 min).<br />
Support algorithms (token bucket, leaky bucket, fixed window, sliding window, hybrid).<br />
Return standardized HTTP 429 responses with retry‑after.<br />
Provide usage visibility (current usage, remaining quota, reset time, history).<br />
Maintain consistent enforcement across regions.<br />
Allow real‑time policy updates without restarts.</p>
<hr />
<h2><strong>2. Non‑Functional Requirements (How the system must behave)</strong></h2>
<p>Low latency (few ms overhead).<br />
High availability (no single point of failure).<br />
Horizontal scalability (millions of RPS and unique keys).<br />
Fairness across tenants and users.<br />
Distributed consistency across nodes.<br />
Fault tolerance (fail‑open or fail‑closed depending on endpoint).<br />
Efficient storage with TTL‑based cleanup.</p>
<hr />
<h2><strong>3. Edge Case Considerations (Special conditions to handle)</strong></h2>
<p>Window‑boundary bursts; clock drift; bot attacks; multi‑AZ traffic; aggressive retries after 429.</p>
<hr />
<h2><strong>4. High‑Level Architecture (How the system is structured)</strong></h2>
<p>Flow: client → gateway → rate limiter → backend.<br />
Components: API gateway, rate limiter service, configuration service, counter storage (Redis/DynamoDB), metrics/logging, optional coordination layer.<br />
Variants: in‑process, centralized service, Redis‑based distributed limiter, edge/CDN enforcement.<br />
Workflow: extract key → check counters → apply algorithm → allow/deny → log/metrics.</p>
<pre class="codehilite"><code class="language-mermaid">flowchart LR

    A[Client] --&gt; B[API Gateway&lt;br/&gt;Extract rate-limit key]
    B --&gt; C[Rate Limiter Service&lt;br/&gt;Rule evaluation, algorithm logic, policy lookup]
    C --&gt; D[Counter Storage&lt;br/&gt;Redis, DynamoDB, or in-memory&lt;br/&gt;Atomic ops, TTL, token state]
    D --&gt; C

    C --&gt;|Allow| E[Backend Service]
    C --&gt;|Deny| F[HTTP 429 Too Many Requests]

    C --- G[Configuration Service&lt;br/&gt;Policy distribution, hot reload]
    C --- H[Metrics and Logging&lt;br/&gt;Usage stats, observability]
    C --- I[Distributed Coordination Layer&lt;br/&gt;Multi-region sync, consistency]
</code></pre>

<hr />
<h2><strong>5. Algorithms (How limits are enforced)</strong></h2>
<p>Fixed window (simple, bursty).<br />
Sliding window log (accurate, heavy).<br />
Sliding window counter (balanced).<br />
Token bucket (industry standard, burst‑friendly). <br />
Leaky bucket (smooths traffic).<br />
Choice depends on accuracy, burst tolerance, latency, and storage cost.</p>
<hr />
<h2><strong>6. State &amp; Storage (Where counters live)</strong></h2>
<p>In‑memory (fast, inconsistent).<br />
Redis (atomic ops, low latency).<br />
NoSQL (global consistency, higher latency).<br />
Data structures: integers, sorted sets, ring buffers, token counters + timestamps.<br />
Memory management: TTLs, auto‑delete, log pruning.<br />
Atomicity via Lua scripts or conditional updates.</p>
<hr />
<h2><strong>7. Distributed Enforcement (How to stay correct across nodes/regions)</strong></h2>
<p>Local limits fail due to partial visibility.<br />
Centralized Redis cluster: atomic, low latency, hotspot‑prone.<br />
Sharding via consistent hashing: spreads load.<br />
Multi‑region: handle replication lag, divergence, partitions; use regional quotas, CRDTs, or token preallocation.<br />
Consistency models: strong, eventual, bounded staleness.<br />
Failure modes: fail‑open vs fail‑closed.</p>
<pre class="codehilite"><code class="language-mermaid">flowchart LR
    subgraph RegionA
        GA[Gateways]
        RA[Redis Shard A]
    end

    subgraph RegionB
        GB[Gateways]
        RB[Redis Shard B]
    end

    GA --&gt; RA
    GB --&gt; RB
    RA &lt;--&gt; RB
</code></pre>

<hr />
<h2><strong>8. Enforcement Placement (Where limits are applied)</strong></h2>
<p>Client‑side (rare).<br />
Edge gateways (Cloudflare/AWS).<br />
Reverse proxies (NGINX/Envoy).<br />
Service mesh sidecars (Istio/Envoy).<br />
Centralized microservice.<br />
Policies distributed via hot‑reloading.</p>
<hr />
<h2><strong>9. Scaling &amp; Resilience (How to handle massive traffic)</strong></h2>
<p>Scale gateways, services, and Redis clusters horizontally.<br />
Avoid hot keys; use caching and pre‑warming.<br />
Smooth bursts; apply backoff and circuit breakers.<br />
Plan for Redis outages, partitions, node crashes.<br />
Monitor latency, errors, key distribution, refill behavior, cross‑region sync lag.</p>
<hr />
<h2><strong>10. End‑to‑End Example (Production pattern)</strong></h2>
<p>Token bucket + Redis with atomic Lua scripts.<br />
Multi‑region token distribution.<br />
Tenant‑specific policies.<br />
Dashboards and logs for debugging.  </p>
<pre class="codehilite"><code class="language-mermaid">sequenceDiagram
    participant Client
    participant Gateway
    participant Limiter
    participant Redis
    participant Backend

    Client-&gt;&gt;Gateway: Request
    Gateway-&gt;&gt;Limiter: Check rate limit
    Limiter-&gt;&gt;Redis: Atomic token update
    Redis--&gt;&gt;Limiter: Result
    Limiter--&gt;&gt;Gateway: Allow or Deny
    Gateway-&gt;&gt;Backend: Forward if allowed
</code></pre>

<hr />
        
        <div class="footer">
            <p>Generated on: 1766782375.8168092</p>
            <p>3 Mermaid diagram(s) included as code blocks</p>
            <p>For visualization, copy Mermaid code to: https://mermaid.live/</p>
        </div>
    </body>
    </html>
    