<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rate Limiter Documentation</title>
<script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<style>
body {font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; line-height: 1.5; color: #333; max-width: 100%; margin: 0; padding: 5px 10px; background: #ffffff;}
h1 {font-size: 1.8em; border-bottom: 2px solid #3498db; padding-bottom: 5px; margin: 10px 0 8px 0; color: #2c3e50;}
h2 {font-size: 1.4em; border-bottom: 1px solid #bdc3c7; padding-bottom: 3px; margin: 8px 0 6px 0; color: #2c3e50;}
h3 {font-size: 1.2em; color: #34495e; margin: 6px 0 4px 0;}
p {margin: 6px 0;}
code {background: #f8f9fa; padding: 2px 6px; border-radius: 3px; font-family: "Courier New", monospace; font-size: 0.95em; color: #c7254e;}
pre {background: #f8f9fa; padding: 8px; border-radius: 3px; border-left: 3px solid #3498db; overflow-x: auto; margin: 8px 0;}
blockquote {border-left: 3px solid #3498db; padding-left: 8px; margin: 8px 0; color: #555; background: #f8f9fa; font-style: italic;}
table {border-collapse: collapse; width: 100%; margin: 8px 0;}
th, td {border: 1px solid #ddd; padding: 6px; text-align: left;}
th {background-color: #3498db; color: white; font-weight: bold;}
tr:nth-child(even) {background-color: #f9f9f9;}
ul, ol {margin-left: 20px; margin-top: 4px; margin-bottom: 4px;}
li {margin-bottom: 3px;}
a {color: #3498db; text-decoration: none;}
a:hover {text-decoration: underline;}
.mermaid {margin: 8px 0; padding: 10px; background: #f8f9fa; border: 1px solid #3498db; border-radius: 4px; text-align: center; font-size: 14px;}
.mermaid svg {font-size: 14px;}
.header {text-align: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #3498db;}
.footer {text-align: center; font-size: 0.8em; color: #666; margin-top: 10px; padding-top: 8px; border-top: 1px solid #bdc3c7;}
@media print {
body {font-family: Arial, sans-serif; line-height: 1.4; color: #000; margin: 0.1in; font-size: 10pt; max-width: 100%;}
h1 {font-size: 16pt; color: #0066cc; border-bottom: 1px solid #0066cc; padding-bottom: 3px; margin: 8px 0 6px 0;}
h2 {font-size: 13pt; color: #0066cc; margin: 6px 0 4px 0; border-bottom: 1px solid #ccc; padding-bottom: 2px;}
h3 {font-size: 11pt; color: #333; margin: 4px 0 3px 0;}
code {background: #f5f5f5; padding: 1px 2px; border-radius: 2px; font-size: 9pt;}
pre {background: #f5f5f5; padding: 4px; border-radius: 2px; border-left: 2px solid #0066cc; page-break-inside: avoid; margin: 4px 0;}
blockquote {border-left: 2px solid #0066cc; padding-left: 6px; margin: 4px 0; background: #f9f9f9;}
table {border-collapse: collapse; width: 100%; margin: 4px 0; page-break-inside: avoid;}
th, td {border: 1px solid #ddd; padding: 4px; font-size: 9pt;}
th {background-color: #0066cc; color: white;}
ul, ol {margin-left: 12px; margin-top: 3px; margin-bottom: 3px;}
.mermaid {margin: 4px 0; padding: 6px; background: #f0f0f0; border: 1px solid #ccc; page-break-inside: avoid; font-size: 12px;}
.header, .footer {display: none;}
.mermaid svg {max-width: 100% !important; height: auto !important; font-size: 12px;}
}
</style>
</head>
<body>
<div class="header">
<h1>Rate Limiter Documentation</h1>
<p>Generated from Rate Limiter.md</p>
<p style="font-size: 0.85em; color: #888;">Mermaid diagrams are rendered below</p>
</div>
<div id="content">
<h1><strong>RATE LIMITER SYSTEM DESIGN</strong></h1>
<h2><strong>1. Functional Requirements (What the rate limiter must do)</strong></h2>
<p>Enforce quotas (per IP, user, API key, service, tenant, endpoint).<br />
Support multiple policies (100/min, 10/sec, 1,000/hour, 5 login attempts/10 min).<br />
Support algorithms (token bucket, leaky bucket, fixed window, sliding window, hybrid).<br />
Return standardized HTTP 429 responses with retry‑after.<br />
Provide usage visibility (current usage, remaining quota, reset time, history).<br />
Maintain consistent enforcement across regions.<br />
Allow real‑time policy updates without restarts.</p>
<hr />
<h2><strong>2. Non‑Functional Requirements (How the system must behave)</strong></h2>
<p>Low latency (few ms overhead).<br />
High availability (no single point of failure).<br />
Horizontal scalability (millions of RPS and unique keys).<br />
Fairness across tenants and users.<br />
Distributed consistency across nodes.<br />
Fault tolerance (fail‑open or fail‑closed depending on endpoint).<br />
Efficient storage with TTL‑based cleanup.</p>
<hr />
<h2><strong>3. Edge Case Considerations (Special conditions to handle)</strong></h2>
<p>Window‑boundary bursts; clock drift; bot attacks; multi‑AZ traffic; aggressive retries after 429.</p>
<hr />
<h2><strong>4. High‑Level Architecture (How the system is structured)</strong></h2>
<p>Flow: client → gateway → rate limiter → backend.<br />
Components: API gateway, rate limiter service, configuration service, counter storage (Redis/DynamoDB), metrics/logging, optional coordination layer.<br />
Variants: in‑process, centralized service, Redis‑based distributed limiter, edge/CDN enforcement.<br />
Workflow: extract key → check counters → apply algorithm → allow/deny → log/metrics.</p><pre class="mermaid">
flowchart LR

    A[Client] --> B[API Gateway<br/>Extract rate-limit key]
    B --> C[Rate Limiter Service<br/>Rule evaluation, algorithm logic, policy lookup]
    C --> D[Counter Storage<br/>Redis, DynamoDB, or in-memory<br/>Atomic ops, TTL, token state]
    D --> C

    C -->|Allow| E[Backend Service]
    C -->|Deny| F[HTTP 429 Too Many Requests]

    C --- G[Configuration Service<br/>Policy distribution, hot reload]
    C --- H[Metrics and Logging<br/>Usage stats, observability]
    C --- I[Distributed Coordination Layer<br/>Multi-region sync, consistency]

</pre><hr />
<h2><strong>5. Algorithms (How limits are enforced)</strong></h2>
<p>Fixed window (simple, bursty).<br />
Sliding window log (accurate, heavy).<br />
Sliding window counter (balanced).<br />
Token bucket (industry standard, burst‑friendly). <br />
Leaky bucket (smooths traffic).<br />
Choice depends on accuracy, burst tolerance, latency, and storage cost.</p>
<hr />
<h2><strong>6. State &amp; Storage (Where counters live)</strong></h2>
<p>In‑memory (fast, inconsistent).<br />
Redis (atomic ops, low latency).<br />
NoSQL (global consistency, higher latency).<br />
Data structures: integers, sorted sets, ring buffers, token counters + timestamps.<br />
Memory management: TTLs, auto‑delete, log pruning.<br />
Atomicity via Lua scripts or conditional updates.</p>
<hr />
<h2><strong>7. Distributed Enforcement (How to stay correct across nodes/regions)</strong></h2>
<p>Local limits fail due to partial visibility.<br />
Centralized Redis cluster: atomic, low latency, hotspot‑prone.<br />
Sharding via consistent hashing: spreads load.<br />
Multi‑region: handle replication lag, divergence, partitions; use regional quotas, CRDTs, or token preallocation.<br />
Consistency models: strong, eventual, bounded staleness.<br />
Failure modes: fail‑open vs fail‑closed.</p><pre class="mermaid">
flowchart LR
    subgraph RegionA
        GA[Gateways]
        RA[Redis Shard A]
    end

    subgraph RegionB
        GB[Gateways]
        RB[Redis Shard B]
    end

    GA --> RA
    GB --> RB
    RA <--> RB
</pre><hr />
<h2><strong>8. Enforcement Placement (Where limits are applied)</strong></h2>
<p>Client‑side (rare).<br />
Edge gateways (Cloudflare/AWS).<br />
Reverse proxies (NGINX/Envoy).<br />
Service mesh sidecars (Istio/Envoy).<br />
Centralized microservice.<br />
Policies distributed via hot‑reloading.</p>
<hr />
<h2><strong>9. Scaling &amp; Resilience (How to handle massive traffic)</strong></h2>
<p>Scale gateways, services, and Redis clusters horizontally.<br />
Avoid hot keys; use caching and pre‑warming.<br />
Smooth bursts; apply backoff and circuit breakers.<br />
Plan for Redis outages, partitions, node crashes.<br />
Monitor latency, errors, key distribution, refill behavior, cross‑region sync lag.</p>
<hr />
<h2><strong>10. End‑to‑End Example (Production pattern)</strong></h2>
<p>Token bucket + Redis with atomic Lua scripts.<br />
Multi‑region token distribution.<br />
Tenant‑specific policies.<br />
Dashboards and logs for debugging.  </p><pre class="mermaid">
sequenceDiagram
    participant Client
    participant Gateway
    participant Limiter
    participant Redis
    participant Backend

    Client->>Gateway: Request
    Gateway->>Limiter: Check rate limit
    Limiter->>Redis: Atomic token update
    Redis-->>Limiter: Result
    Limiter-->>Gateway: Allow or Deny
    Gateway->>Backend: Forward if allowed
</pre><hr />
</div>
<div class="footer">
<p>Generated: 1766783736.367595</p>
<p>3 Mermaid diagram(s) rendered with Mermaid.js</p>
<p>For printing: Use Ctrl+P and select "Save as PDF"</p>
</div>
<script>
// Initialize Mermaid with startOnLoad: true as per instructions
mermaid.initialize({ startOnLoad: true, theme: "default", securityLevel: "loose", fontFamily: "Arial, sans-serif", fontSize: 14 });
</script>
<script>
// Highlight code blocks (non-mermaid)
document.addEventListener("DOMContentLoaded", function() {
var blocks = document.querySelectorAll("pre code");
for (var i = 0; i < blocks.length; i++) {
if (typeof hljs !== "undefined" && !blocks[i].classList.contains("mermaid")) {
hljs.highlightElement(blocks[i]);
}
}
});
</script>
</body>
</html>